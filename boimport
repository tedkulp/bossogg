#!/usr/bin/python

#boimport - Import Script for:
#Boss Ogg - A Music Server
#(c)2003 by Jef Spaleta (jspaleta@users.sf.net)
#This project's homepage is: http://bossogg.wishy.org
#
#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

from __future__ import generators
from boss3.util import UTFstring
from boss3.xmlrpc import bossxmlrpclib as xmlrpclib
import getopt,os,sys,re,types,stat,string,time,traceback
from boss3.util.Session import *


def walktree(top=".", depthfirst=False):
	"""
	Walk a directory tree, starting from 'top'

	This code is based on os.path.walk, with the callback function
	replaced by a yield and recursion replaced by iteration
	"""
	firstpass=True
	if type(top) != types.StringType:
		raise TypeError("top must be a string")

	# decide which end of the stack to pop
	if depthfirst:
		index = -1
	else:
		index = 0
	
	dirstack = [top]
	while dirstack:
		top = dirstack.pop(index)
		if os.path.isfile(top):
			if firstpass:
				(top,name)=os.path.split(top)
				firstpass=False
				names=[name,]
			else:
				return
		else:
			try:
				names = os.listdir(top)
			except os.error:
				return
		yield top, names
		if firstpass:
			dirs = []
			for name in names:
				name = os.path.join(top, name)
				try:
					st = os.lstat(name)
				except os.error:
					continue
				if stat.S_ISDIR(st.st_mode):
					dirs.append(name)
					# the depth-first results look 'backwards' to me
					# so I'm changing them to fit my expectations
			if depthfirst:
				dirs.reverse()
				dirstack.extend(dirs)

def usage():
	print "boimport usage: [ -u|--update -d|delete -l|--list ] [options] file1 file2 ..."
	print "Main modes (mutually exclusive options):"
	print "  No options:\t\tattempt to add/update files"
	print "  -u|--update:\t\tupdate bossogg cache timestamps"
	print "  -d|--delete:\t\tdelete specified files from bossogg database"
	print "  -l|--list no files:\t\tlists songs in bossogg cache needing updating"
	print "  -l|--list with files:\t\tlist songinfo for specified files"
	print "Options:"
	print "  -c|--cleanup\t\tClean bossogg database of files that no longer exist"
	print "  -i|--interactive\tInteractively input song information"
	print "  -f|--force\t\tforce song update,disregarding modification timestamp"
	print "  -w|--write\t\twrite user defined tags to file"
	print "  -T|--Type\t\tTag header type"
	print "  -H|--Host\t\tBossogg host url"
	print "  -v|--verbose\t\tadd logging level"
	print "  -q|--quiet\t\tSuppress errors and warnings"
	print "  -R|--recurse\t\tRecursively enter the directory argument"
	print "  -F|--format\t\tformat string to encode tag info from filename"
	print "  -C|--cover\t\tformat string to find coverart file associated with each song"
	print "Required Tag Fields: must be provided through user input or file header"
	print "  -a|--artist\t\talbum artist (required)"
	print "  -t|--title\t\talbum title (required)"
	print "  -n|--num\t\ttrack number (required/autogenerated)"
	print "  -s|--song\t\tsong title (required/autogenerate)"
	print "Optional Tag Fields:"
	print "  -y|--year\t\talbum year (optional)"
	print "  -m|--metaartist\t\tmetaartist for multiple artist albums (optional)"
	print "  -S|--Sec\t\tsong length in seconds (optional)"
	print "  -G|--Gain\t\tReplaygain:Album Gain (optional)"
	print "  -g|--gain\t\tReplaygain:Track Gain (optional)"
	print "  -P|--Peak\t\tReplaygain:Album Peak (optional)"
	print "  -p|--peak\t\tReplaygain:Track Peak (optional)"
	print "Format string tags:"
	print "  %artist% %album% %song% %track% %year% %ext% "
	print "  %space1% %space2% %space3% %space4% %space5%"
	print "  %space6% %space7% %space8% %space9% %metaartist%"
	print "  You can have multiple -F arguments to match different filename formats."
	print "  The first -F to match a filename is used"
def main():
	session = Session()
	session['loglevel'] = 1
	longoptions=["help", "verbose","quiet","interactive","update","force","delete","list","write","cleanup","Type=","Host=","artist=","title=","song=","num=","year=","Sec=","Gain=","gain=","Peak=","peak=","format=","cover="]
	try:
		opts, args = getopt.getopt(sys.argv[1:], "qhcwRiudlfH:b:T:a:m:t:n:s:y:S:P:p:G:g:F:C:v",longoptions)
	except getopt.GetoptError:
		# print help information and exit:
		usage()
		sys.exit(2)
	if len(opts) +len(args) == 0:
		usage()
		sys.exit()
		
	host="http://localhost:4069"	
	tagtype = None
	new={'albumname':None,'artistname':None}
	old={'albumname':None,'artistname':None}
	verbose = 0
	filestoimport=[]
	filestodelete=[]
	ctags={}
	itags={}
	ptags={}
	htags_defaults={'artistname':None,'metaartistname':'','albumname':None,'year':0000,'tracknum':None,'songname':None
		   #,'filename':None
		   #, 'track_peak':0.0,'track_gain':0.0,'album_peak':0.0,'album_gain':0.0
		   ,'frontcover':""
		   }
	(recurse, interactive,delete,update,cleanup,listinfo,
	 playing,empty,force,quiet,proto,coverproto,coverfile) = (False,
								  False,False,False,False,False,False,False,False,False,False,False,False)
	htags = htags_defaults.copy()
	protos = []
	for o, a in opts:
		if o == "-v":
			verbose=verbose+1
			session['loglevel'] += 1
		if o in ("-h", "--help"):
			usage()
			sys.exit()
	for o, a in opts:
		if o in ("-a", "--artist"):
			ctags["artistname"] = a
			if verbose: print "input artist: %s" %(ctags["artistname"],)
		if o in ("-m", "--metaartist"):
			ctags["metaartistname"] = a
			if verbose: print "input metaartist: %s" %(ctags["metaartistname"],)
		if o in ("-t", "--title"):
			ctags["albumname"] = a
			if verbose: print "input album: %s" %(ctags["albumname"],)
		if o in ("-s", "--song"):
			ctags["songname"] = a
			if verbose: print "input song: %s" %(ctags["songname"],)
		if o in ("-n", "--num"):
			ctags["tracknum"] = a
			if verbose: print "input tracknum: %s" %(ctags["tracknum"],)
		if o in ("-y", "--year"):
			ctags["year"] = a
			if verbose: print "input year: %s" %(ctags["year"],)
		if o in ("-G", "--Gain"):
			ctags["album_gain"] = a
			if verbose: print "input album_gain: %f" %(ctags["album_gain"],)
		if o in ("-P", "--Peak"):
			ctags["album_peak"] = a
			if verbose: print "input album_peak: %f" %(ctags["album_peak"],)
		if o in ("-g", "--gain"):
			ctags["track_gain"] = a
			if verbose: print "input track_gain: %f" %(ctags["track_gain"],)
		if o in ("-p", "--peak"):
			ctags["track_peak"] = a
			if verbose: print "input track_peak: %f" %(ctags["track_peak"],)
		if o in ("-R", "--recurse"):
			recurse = True
			if verbose: print "recursing"
		if o in ("-q", "--quiet"):
			quiet = True
			if verbose: print "quiet mode"
		if o in ("-i", "--interactive"):
			interactive = True
			if verbose: print "interactive mode"
		if o in ("-u", "--update"):
			update = True
			if verbose: print "updating database timestamps"
		if o in ("-c", "--clean"):
			cleanup = True
			if verbose: print "updating database timestamps"
		if o in ("-f", "--force"):
			force = True
			if verbose: print "force reimport of all files"
		if o in ("-d", "--delete"):
			delete = True
			if verbose: print "delete mode"
		if o in ("-c", "--clean"):
			cleanup = True
			if verbose: print "delete mode"
		if o in ("-l", "--list"):
			listinfo = True
			if verbose: print "list song information"
		if o in ("-w", "--write"):
			write = True
			if verbose: print "write user defined tags to files"
		if o in ("-T", "--Type"):
			tagtype = a
			if verbose: print "User selected tag type %s" % (tagtype,)
		if o in ("-H", "--Host"):
			host = a
			if verbose: print "Bossogg server %s" % (host,)
		if o in ("-F", "--format"):
			proto=a
 			proto = re.sub("%artist%","(?P<artistname>.+)", proto)
			proto = re.sub("%metaartist%","(?P<metaartistname>.+)", proto)
			proto = re.sub("%album%","(?P<albumname>.+)", proto)
			proto = re.sub("%song%","(?P<songname>.+)", proto)
			proto = re.sub("%ext%","(?P<ext>[Oo][Gg][Gg]|[Mm][Pp]3|[Ff][Ll][Aa][Cc])", proto)
			proto = re.sub("%track%","(?P<tracknum>\d+)", proto)
			proto = re.sub("%year%","(?P<year>\d+)", proto)
			proto = re.sub("%dir%","(?P<dir>\d+)", proto)
			proto = re.sub("%space1%","(?P<space1>\d+)", proto)
			proto = re.sub("%space2%","(?P<space2>\d+)", proto)
			proto = re.sub("%space3%","(?P<space3>\d+)", proto)
			proto = re.sub("%space4%","(?P<space4>\d+)", proto)
			proto = re.sub("%space5%","(?P<space5>\d+)", proto)
			proto = re.sub("%space6%","(?P<space6>\d+)", proto)
			proto = re.sub("%space7%","(?P<space7>\d+)", proto)
			proto = re.sub("%space8%","(?P<space8>\d+)", proto)
			proto = re.sub("%space9%","(?P<space9>\d+)", proto)
			
			protos.append(proto)
			
			if verbose: print "Bossogg format string %s" % (proto,)
		if o in ("-C", "--Cover"):
			coverproto=a
	try:
		server = xmlrpclib.ServerProxy(host)
	except:
		if not quiet: print "Error connecting to the server"
		sys.exit(1)
	try:
		sessionid=server.auth("login","blah","blah")
		if verbose: print "Session Id: %s" % sessionid
	except:
		#if not quiet: print "Session Id Error"
		if not quiet: print "Error connecting to the server"
		sys.exit(1)
	try:
		cachearr=server.db("importcache")
		if verbose: print "Found %d cached files" % len(cachearr)
		cache={}
	except:
		if not quiet: print "Cache Error"
		sys.exit(1)
	cache=dict([(item['filename'].data,item['modifieddate'])for item in cachearr])
	if listinfo:
		if len(args) == 0:
			if not quiet: print "List files in the cache that need updating:"
			for filename in cache.keys():
				if (float(cache[filename]) < float(os.stat(filename)[9])):
					print "%s" % filename
			sys.exit()
	if interactive:
		print "Entering interactive mode"
	for arg in args:
		if recurse:
			if verbose: print "recursing"
		for top,names in walktree(arg,True):
			count=0
			for name in names:
				htags = htags_defaults.copy()
				count=count+1
				filename=os.path.join(top,name)
				if verbose>1: print filename
				if listinfo:
					if not quiet: print "Asking for songinfo for %s" % (filename,)
					#try:
					#	sids=server.search({'filename':filename,})
					#	songinfo=server.songinfo(sids[0])
					#except:
					#	if not quiet: print "Error: search"
					#	sys.exit(1)
					#for info in songinfo.keys():
					#	print "%s: %s" % (info,songinfo[info])

				elif delete:
					if cache.has_key(filename):
						if verbose: print "%s can be deleted from database" % (filename,)
						filestodelete.append(filename)
					else :
						if verbose: print "%s NOT in the database" % (filename,)
				else:
					skip=False
					if os.path.isfile(filename):
						if interactive:
							print "File: %s"%(filename,)
						if cache.has_key(filename):
							if (float(cache[filename]) < float(os.stat(filename)[9]) or force):
								if verbose: print "%s is in database, checking for needed update" % (filename,)
								#try:
								#	sids=server.search({'filename':UTFstring.encode(filename),})
								#	songinfo=server.songinfo(sids[0])
								#except:
								#	if not quiet: print "Error: songinfo search"
								#	sys.exit(1)
								#for tag  in htags.keys():
								#	if songinfo.has_key(tag):
								#		htags[tag]=songinfo[tag]
								#	elif songinfo.has_key(tag+'name'):
								#		htags[tag]=songinfo[tag+'name']
								#	elif songinfo.has_key('album_'+tag):
								#		htags[tag]=songinfo['album_'+tag]
								htags['songname']=filename
								htags['tracknum']=count
							else: skip=True
						else:
							if verbose: print "new file %s" %filename
							htags['songname']=filename
							htags['tracknum']=count
						if not skip:	
							if string.upper(name[-4:]) == ".OGG":
								filetype="OGG"
								if verbose: print "Found an ogg file %s" % (name,)
							elif string.upper(name[-5:]) == ".FLAC":
								filetype="FLAC"
								if verbose: print "Found a flac file %s" % (name,)
							elif string.upper(name[-4:]) == ".MP3":
								filetype="MP3"
								if verbose: print "Found an mp3 file %s" % (name,)
							else:
								if not quiet: print "Error: Unsupported Filetype for %s" %(filename,)
								skip=True
						if not skip:
							if protos :
								for proto in protos:
									pmatch=re.search(proto, filename)
									if pmatch:
										break
									

								if verbose: print pmatch.groupdict()
								if isinstance(pmatch, types.NoneType) == False:
										ptags=pmatch.groupdict()
										if verbose: print htags
										if coverproto:
											for key in ptags.keys():
												coverstr= "%%%s%%" % (key,)
												print coverstr
												coverfile=re.sub(coverstr,ptags(key), coverproto)
											if os.path.isfile(coverfile):
												if verbose: print "Cover file for %s is %s" % (filename.coverfile)
											else:
												if not quiet: print "Cover Proto Error for %s: %s" % (filename,coverfile)
												coverfile=False
										if coverfile:
											htags['frontcover']=coverfile
							else:
								try:
									infograb=False
									fileinfo=server.db('upload',UTFstring.encode(filename))
									infograb=True
								except:
									print "Upload error"
									sys.exit(1)
								if infograb:
									for key in fileinfo.keys():
										if htags.has_key(key):
											htags[key]=UTFstring.decode(fileinfo[key])
							for key in htags.keys():
								if ctags.has_key(key):
									if verbose: print "%s: \"%s\" found on commandline" % (key,ctags[key])
									htags[key]=ctags[key]
								if proto:
									if ptags.has_key(key):
										if verbose: print "%s: \"%s\" found in the protostring" % (key,ptags[key])
										htags[key]=ptags[key]
								if interactive:
									ustring=UTFstring.decode(htags[key])
									if isinstance(ustring, types.UnicodeType):
										ustring=ustring.encode('latin-1','replace')
									#if isinstance(ustring, types.StringType):
									if (key=='artistname') and (ustring==old[key]) and not (old[key] == None):
										htags[key]=new[key]
									else: 
										if (key=='albumname') and (ustring==old[key]) and not (old[key] == None):
											htags[key]=new[key]
										else:
											input=raw_input("Enter new %s info [%s]->"%(key,ustring))
											if string.strip(input)!='': 
												if key=='artistname':
													old[key]=htags[key]
													new[key]=string.strip(input)
												if key=='albumname':
													old[key]=htags[key]
													new[key]=string.strip(input)
												htags[key]=string.strip(input)
											else:
												if verbose: print "input was blank using old %s value: %s" %(key,ustring)
												if key=='artistname':
													old[key]=htags[key]
													new[key]=old[key]
												if key=='albumname':
													old[key]=htags[key]
													new[key]=old[key]
							for key in htags:
								if htags[key] == None:
									if not quiet: print "Error: no %s info: %s" % (key,filename)
									skip=True
								else:
									if verbose>1: print "%s: %s" %(key,htags[key])
						if not skip:
							if verbose: print "Import %s" % (filename,)
							htags['year']=int(htags['year'])
							htags['tracknum']=int(htags['tracknum'])
							if htags.has_key('album_gain'):
								htags['album_gain']=float(htags['album_gain'])
							if htags.has_key('album_peak'):
								htags['album_peak']=float(htags['album_peak'])
							if htags.has_key('track_gain'):
								htags['track_gain']=float(htags['track_gain'])
							if htags.has_key('track_peak'):
								htags['track_peak']=float(htags['track_peak'])
							htags['filename']=filename
							for key in htags:
								tmp=UTFstring.encode(htags[key])
								htags[key] = tmp
							filestoimport.append(htags.copy())
							del htags['filename']
	if cleanup:
		for filename in cache.keys():
			if not os.path.isfile(filename):			
				if verbose: print "%s no longer exists, remove from bossogg cache" % (filename,)
				filestodelete.append(filename,)

	#if not quiet:
	#	print "Number of songs to import %d" % len(filestoimport)
	#	print "Number of songs to delete %d" % len(filestodelete)

	if len(filestoimport) > 0 or len(filestodelete) > 0:
		#try:
		#	status=server.control("status")
		#except:
		#	if not quiet: print "Status Error"
		#	sys.exit()
		#if status['playerstatus'] == 'PLAYING':
		#	if verbose: print "Server is playing pause while importing"
		#	playing=True
		#	server.pause()
		#if status['playerstatus'] == 'EMPTY DB':
		#	empty=True
		#	if verbose: print "Empty Database, db must be reloaded"
		try:
			response=server.db("importstart")
		except:
			if not quiet: print "Error: Import Start"
			sys.exit(1)
		for filestruct in filestoimport:
			if verbose: print "Call importsong for %s" % (filestruct['filename'].data,)
		if not quiet:
			print "Starting Song Import:",
		for file in filestoimport:
			print "#",
			sys.stdout.flush()
			try:
				server.db("importsong",file)
			except:
				traceback.print_exc()
				if not quiet: print "Error: Import Song (%s)" % file['filename']
		print
		if not quiet and cleanup: print "Starting Server Cache Cleanup"
		if verbose: print "Calling importdelete for filestodelete: %s" % type(filestodelete)
		try:
			response=server.db("importdelete",filestodelete)
		except:
			if not quiet: print "Error: Deleting Song"
			if verbose: print response
		if verbose: print "%d Songs were deleted reloading the db" % (len(filestodelete),)
		try:
			response=server.db("importend")
		except:
			if not quiet: print "Error: Import End"
			sys.exit(1)
		if not quiet:
			print "Number of songs imported %d" % len(filestoimport)
			if cleanup or len(filestodelete)>0:
				print "Number of songs deleted %d" % len(filestodelete)


		#if len(filestodelete) > 0 or empty:
		#	response=server.reload_db()
		#	if verbose: print response
		#elif playing:
		#	if verbose: print "Resume playing from paused location"
		#	response=server.play()
if __name__ == "__main__":
	main()

# vim:ts=8 sw=8 noet
